---
title: "Functional Programming - Back to Basics"
author: "Eryn McFarlane"
date: "09/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Why do we do Functional Programming

The whole point is to 1) make your life easier because you don't need to manually re-do the same processes you've already done and 2) cut down on error by copy and pasting. 

General rule: if you're going to do something more than twice, it's worth figuring out a smarter way to do it. 

For example, you might want to do multiple plots, which differ only in their input (e.g. graphing the same x and y for different years). You might want to process data from different files in the same way etc. 

If you write a function or a loop, then you will only need to change code in one place, if you need to change it, as compared to finding all of the places you might have implemented it (again, increasing the likelihood of errors). 


```{r}
### make up some data
df<-data.frame(cbind(rnorm(100, 0, 1), rnorm(100, 5, 3)))
```

Let's write a (very simple) function:

```{r}
function1<-function(x,y){
  #do something with x and y
  x+y
}

function1(df[,1], df[,2])

df[,1]+df[,2]
```

Obviously this is a really simple function. I've just told the function that I was going to give it two arguments, and that I wanted it to add them together. 

Now, we don't need to only use this on the made up data, we can use it on any two arguments

```{r}

function1(1, 100)
```

We can make this function as simple or as difficult as we like. If it's something that is going to be used accross multiple projects, it's worth saving it separately so that it can be called using source(). 

We can also put as many arguments into as we like. We can also name them whatever we like. 

```{r}
function2<-function(one, two, red, blue){
  (one+two)*red/blue
}

function2(1, 2, 3, 4)
```

Let's look a little bit at loops. 

In R, there are for loops and while loops. I've never used a while loop, so for loops. 

For loops iterate through the items, and perform some action on each of them. 


```{r}
for(i in 1:3){
  ## do the thing
  print("the thing")
}
```

Perhaps with our data, we want to standardize each point by the mean and the standard deviation. 

```{r}

for(i in 1:length(df[,1])){
  df[i, 3]<-df[i,1]-mean(df[,1])/sd(df[,1])
}
```

Excellent. Except maybe we want to do this for each of our rows.


```{r}
str(df)
df<-df[,c(1:2)] # get back to original df
df_std<-matrix(NA, nrow=100, ncol=2) ##make a new matrix to chuck the standardize values in

for(j in 1:ncol(df)){
  for(i in 1:nrow(df)){
  df_std[i, j]<-(df[i,j]-mean(df[,j]))/sd(df[,j])
    }
}

head(df_std)
```

So you can see that you can put loops inside loops inside loops. This is not always efficient, and it's easy to lose some things. This is where the amazing 'apply' group of functions comes in.


For example, we can write a function, and run it on df using lappy. 
Let's take our fake data, and add a category to it. 

```{r}
df[,3]<-rep(c("yes", "no"), 50)
function3<-function(x){
  (x-mean(x))/sd(x)
}

lapply(df[,c(1:2)], function3)
sapply(df[,c(1:2)], function3)
tapply(df[,1], df[,3], function3)

```