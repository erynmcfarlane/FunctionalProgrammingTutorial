---
title: "Functional Programming - Back to Basics"
author: "Eryn McFarlane"
date: "09/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Why do we do Functional Programming

The whole point is to 1) make your life easier because you don't need to manually re-do the same processes you've already done and 2) cut down on error by copy and pasting. 

General rule: if you're going to do something more than twice, it's worth figuring out a smarter way to do it. 

For example, you might want to do multiple plots, which differ only in their input (e.g. graphing the same x and y for different years). You might want to process data from different files in the same way etc. 

If you write a function or a loop, then you will only need to change code in one place, if you need to change it, as compared to finding all of the places you might have implemented it (again, increasing the likelihood of errors). 


```{r}
### make up some data
df<-data.frame(cbind(rnorm(100, 0, 1), rnorm(100, 5, 3)))
```

Let's write a (very simple) function:

```{r}
function1<-function(x,y){
  #do something with x and y
  x+y
}

function1(df[,1], df[,2])

df[,1]+df[,2]
```

Obviously this is a really simple function. I've just told the function that I was going to give it two arguments, and that I wanted it to add them together. 

Now, we don't need to only use this on the made up data, we can use it on any two arguments

```{r}

function1(1, 100)
```

We can make this function as simple or as difficult as we like. If it's something that is going to be used accross multiple projects, it's worth saving it separately so that it can be called using source(). 

We can also put as many arguments into as we like. We can also name them whatever we like. 

```{r}
function2<-function(one, two, red, blue){
  (one+two)*red/blue
}

function2(1, 2, 3, 4)
```

Let's look a little bit at loops. 

In R, there are for loops and while loops. I've never used a while loop, so for loops. 

For loops iterate through the items, and perform some action on each of them. 


```{r}
for(i in 1:3){
  ## do the thing
  print("the thing")
}
```

Perhaps with our data, we want to standardize each point by the mean and the standard deviation. 

```{r}

for(i in 1:length(df[,1])){
  df[i, 3]<-df[i,1]-mean(df[,1])/sd(df[,1])
}
```

Excellent. Except maybe we want to do this for each of our rows.

###ERYN - Right now this loop is working as a code chunk, but not working when I knit it together. What the fork?

```{r}
for(j in 1:ncol(df)){
  for(i in 1:nrow(df)){
  new[[i]]<-df[i,j]-mean(df[,j])/sd(df[,j])
    }
  df[,ncol(df)+1]<-new
  colnames(df)[ncol(df)]<-paste0("std", j)
}
```

So you can see that you can put loops inside loops inside loops. This is not always efficient, and it's easy to lose some things. 

